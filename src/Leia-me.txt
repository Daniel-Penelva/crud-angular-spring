comando para executar o servidor: npm run start

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Utilizar o Angular Material:

Angular Material (site: https://material.angular.io/)
Get Started: (link: https://material.angular.io/guide/getting-started) - Comando para Install Angular Material: ng add @angular/material

Angular Material é uma biblioteca de componentes de interface do usuário (UI) para o Angular, desenvolvida e mantida pela equipe do Angular. 
Ela fornece uma coleção completa de componentes estilizados e prontos para uso que seguem as diretrizes de design do Material Design, uma 
linguagem de design desenvolvida pelo Google.

O Material Design é uma abordagem de design visual que visa criar uma experiência de usuário consistente, moderna e intuitiva em diferentes 
plataformas e dispositivos. 
Os componentes do Angular Material implementam esses princípios de design, fornecendo uma interface coesa e agradável para seus aplicativos 
Angular.

Alguns dos principais componentes fornecidos pelo Angular Material incluem:

1. Botões (Button): Botões estilizados com diferentes tamanhos e estilos.

2. Caixas de diálogo (Dialog): Caixas de diálogo modais para exibir informações ou solicitar ações do usuário.

3. Barras de navegação (Toolbar e Menu): Componentes para criar barras de navegação, menus e menus de contexto.

4. Tabelas (Table): Componentes para exibir dados em formato de tabela.

5. Campos de entrada (Input): Componentes para campos de entrada de texto, seleção e outras interações do usuário.

6. Listas (List): Componentes para criar listas de itens.

7. Cards: Componentes para criar cartões de conteúdo.

8. Slides (Slider): Componentes para criar controles deslizantes interativos.

9. E muitos outros, como Stepper, Chips, Datepicker, Progress Spinner, etc.

Para cada componente criado é preciso fazer o seu respectivo import no app.module.ts.

Além dos componentes, o Angular Material também fornece estilos predefinidos para criar uma aparência consistente em seus aplicativos. A 
biblioteca é altamente personalizável e permite ajustar facilmente a aparência dos componentes para se adequarem ao design exclusivo do seu aplicativo.

Para usar o Angular Material em seu projeto Angular, você precisará instalar a biblioteca usando o gerenciador de pacotes (por exemplo, npm ou 
yarn) e importar os módulos de que você precisa no módulo apropriado do seu aplicativo.

Angular Material é uma escolha popular para desenvolvedores Angular que desejam criar interfaces de usuário atraentes e eficientes de forma 
rápida e consistente, seguindo os princípios do Material Design.

Site: https://material.angular.io/components/categories

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Criando o módulo courses (cursos) e o roteamento
comando: ng g m courses --routing

Criando o componente courses dentro de courses
comando: ng g c courses/courses

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vamos explicar linha por linha:

{path: '', pathMatch: 'full', redirectTo: 'courses' }:
Relembrar path é o caminho; O redirect vai fazer um redirecionamento para a rota courses para quando acessa a raiz da pasta, no caso, o 
http://localhost:4200. 

Esta é a primeira definição de rota. Aqui, definimos que, quando o caminho da URL estiver vazio (''), a rota deve redirecionar para 'courses'. 
O pathMatch: 'full' indica que a rota deve ser correspondida exatamente com a URL inteira para executar o redirecionamento. Portanto, quando o 
usuário acessar a raiz do aplicativo (por exemplo, http://seuapp.com/), ele será redirecionado para http://seuapp.com/courses.

------ // ------

{path: 'courses', loadChildren: () => import('./courses/courses.module').then(m => m.CoursesModule)}:
No import é o caminho do nosso módulo filho, no caso é o caminho do nosso modulo courses (m.CoursesModule).

Esta é a segunda definição de rota. Aqui, estamos dizendo que quando o caminho da URL for 'courses', o módulo CoursesModule deve ser carregado 
de forma dinâmica. Isso é conhecido como carregamento tardio (lazy loading) de um módulo. O carregamento tardio é uma técnica para dividir o 
aplicativo em módulos menores e carregá-los apenas quando necessário, o que pode melhorar o desempenho geral do aplicativo.

O loadChildren é uma propriedade especial das rotas que aceita uma função que retorna uma promise resolvendo para o módulo que deve ser 
carregado. Neste caso, a função () => import('./courses/courses.module').then(m => m.CoursesModule) está importando dinamicamente o módulo 
CoursesModule e retornando-o para ser carregado.

Documentação lazy-loading:
https://angular.io/guide/lazy-loading-ngmodules


-------------------------------------------------------------------- // -----------------------------------------------------------------------
Table do angular material:
https://material.angular.io/components/table/overview

Vamos importar o API do componente no modulo do curso.
https://material.angular.io/components/table/api

OBS. Organizar os imports de acordo com as boas práticas do angular.
Atalho: CTRL + SHIFT + P - TS Hero 

Criar uma interface - comando:


--------- // ----------
<tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

<tr mat-row>:
Essa tag <tr> representa uma linha da tabela. A diretiva mat-row é uma diretiva personalizada fornecida pelo Angular Material que é usada para 
estilizar a linha da tabela de acordo com os estilos do Material Design.

let row: Isso é uma declaração de variável. Aqui, estamos criando uma variável chamada row que representa os dados da linha atual. Essa variável 
é usada para exibir os valores correspondentes em cada célula da tabela.

*matRowDef="let row; columns: displayedColumns;":
Esta é a diretiva matRowDef usada para definir como os dados da tabela devem ser exibidos em cada coluna da tabela. A diretiva é aplicada na 
tag <tr mat-row> e usa duas propriedades: let row e columns: displayedColumns.

O 'displayedColumns' tem a a função de mostrar para cada linha (ou cada registro) que temos na nossa lista que vai ser mostrado  as colunas 
name e category que foram declaradas na  variável 'displayedColumns'. Ou seja, columns: displayedColumns: Aqui, columns é uma palavra-chave que 
representa a matriz de nomes das colunas da tabela, e displayedColumns é uma variável que contém a matriz real de nomes das colunas que 
desejamos exibir na tabela. Essa matriz é usada para mapear os dados da variável row para as colunas corretas da tabela.

--------- // ----------
Utilizando o Cards - Vamos importar o API do componente no modulo do curso.
https://material.angular.io/components/card/api


API reference for Angular Material toolbar - https://material.angular.io/components/toolbar/api
import {MatToolbarModule} from '@angular/material/toolbar';

--------- // ----------
Vamos  criar um modulo numa pasta shared para ter todos os imports do angular material.
Comando: ng g m shared/app-material

-------------------------------------------------------------------- // -----------------------------------------------------------------------
Criar um service
Comando:  ng g s courses/services/courses

Vamos criar uma class de serviço (service) que vai fornecer todos os dados e vai conter toda a lógica de negócio da nossa aplicação. Ou seja, 
tudo que for relacionado a dados, ou manipulação desses dados para que o componente receba o service de forma correta. O service possui uma 
anotação @Injectable que é para injeção de dependência.

Vale ressaltar que ao utilizar o service dentro do nosso componente será para ajudar na nossa lógica, por exemplo, a variável 'courses' no 
courses.component.ts não sabe quais são os dados que vão ser renderizados, pois a responsabilidade disso é do serviço (service) que vai ter 
a função de passar essas informações para o componente. A única coisa que o componente precisa saber é que vai renderizar uma lista de curso.
Também vale ressaltar que os dados vindo servidor (dados = json) serão manipulados pelo service. A chamada entre os servidores da API Sprig e do 
servidor do angular vai ser de formma assincrona. E no angular temos um class utilitária que fornece todos os método para poder fazer essa 
conexão com a nossa API, que é o HttpClient.

O HttpClient é um módulo da biblioteca @angular/common/http que fornece uma maneira fácil e poderosa de realizar requisições HTTP em aplicativos 
Angular. Ele substitui o antigo módulo Http e oferece uma abordagem mais moderna e flexível para lidar com operações de rede.

O HttpClient possui várias características e benefícios importantes:

Requisições HTTP:
O HttpClient permite fazer diferentes tipos de requisições HTTP, como GET, POST, PUT, DELETE e outras. Ele fornece métodos convenientes para 
criar e enviar essas requisições.

Tipagem de Dados:
O HttpClient é integrado ao sistema de tipos do TypeScript, o que significa que ele pode fazer inferências de tipos para as respostas recebidas. 
Isso facilita o tratamento dos dados retornados pelas requisições HTTP e ajuda a evitar erros de tipos.

Observables:
O HttpClient trabalha com Observables, uma abstração poderosa para lidar com fluxos assíncronos de dados. Isso permite que você utilize recursos 
como operadores de transformação, combinação e manipulação de fluxos de dados.

Interceptação de Requisições:
O HttpClient permite criar interceptores que podem ser usados para pré-processar ou pós-processar as requisições e respostas. Isso é útil para 
adicionar cabeçalhos, manipular erros, autenticação e muito mais.

Gestão de Headers:
É fácil definir e manipular cabeçalhos de requisição e resposta usando o HttpClient.

Gestão de Erros:
O HttpClient lida bem com erros HTTP, permitindo que você implemente lógicas específicas para diferentes códigos de status e tipos de erros.

Segurança:
O HttpClient suporta a adição de tokens de autorização, permitindo que você autentique suas requisições.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

O Observable é um conceito fundamental na programação reativa e é amplamente usado no ecossistema Angular. Ele faz parte da biblioteca rxjs 
(Reactive Extensions for JavaScript) e é usado para lidar com fluxos assíncronos de dados e eventos de forma poderosa e flexível.

Aqui estão os principais pontos sobre o Observable no contexto do Angular:

Representação de Fluxo de Dados:
Um Observable é uma representação de um fluxo de dados que pode emitir múltiplos valores ao longo do tempo. Isso o torna ideal para lidar com 
eventos assíncronos, como requisições HTTP, interações de usuário, atualizações de estado e outros cenários.

Operações de Transformação:
A biblioteca rxjs fornece uma ampla gama de operadores que permitem transformar, combinar, filtrar e manipular fluxos de dados. Isso inclui 
operações como map, filter, merge, combineLatest, debounceTime, entre outros. Esses operadores permitem que você aplique lógica complexa aos 
dados do fluxo de maneira elegante.

Gestão de Assinaturas:
Quando você assina um Observable, você cria uma conexão entre o produtor (Observable) e o consumidor (assinante). Isso permite que os assinantes 
recebam os valores emitidos pelo Observable. O método subscribe é usado para iniciar essa assinatura e você pode fornecer funções para tratar os 
valores emitidos, erros e conclusão.

Controle de Cancelamento:
As assinaturas de Observable podem ser canceladas, o que permite que você gerencie eficientemente os recursos e interrompa a execução de fluxos 
de dados quando necessário. Isso é particularmente útil para liberar recursos após a conclusão de uma tarefa assíncrona.

Gerenciamento de Estado:
Os Observables são frequentemente usados para gerenciar o estado de um aplicativo. Eles podem representar a evolução de um estado ao longo do 
tempo, permitindo que você reaja a alterações e atualizações de forma eficiente.

Suporte a Assíncrono:
Observables são ideais para lidar com programação assíncrona, pois oferecem um mecanismo poderoso para lidar com eventos que ocorrem em momentos 
diferentes.

--------- // ----------

Esse script é um método que faz uma requisição HTTP GET usando o serviço HttpClient do Angular para obter uma lista de cursos. Vou explicar cada 
parte do script:

list() {
    return this.httpClient.get<Course[]>(this.API).pipe(first(),
      tap(courses => console.log(courses))
      );
  }

  Aqui está uma explicação detalhada:

list() { ... }:
Isso é um método chamado list() definido no serviço (ou classe). Esse método é usado para buscar uma lista de cursos.

return this.httpClient.get<Course[]>(this.API):
Isso faz uma requisição HTTP GET para o endpoint definido na variável this.API. this.httpClient é uma instância do serviço HttpClient do Angular, 
e get<Course[]> indica que estamos fazendo uma requisição GET e esperamos uma lista de objetos do tipo Course.

.pipe(...):
O método pipe() é usado para encadear operadores do rxjs (Reactive Extensions for JavaScript) e manipular o fluxo de dados emitido pelo 
Observable resultante da requisição HTTP.

first():
O operador first() é usado para pegar apenas o primeiro valor emitido pelo Observable e, em seguida, completar a assinatura. Isso é útil para 
garantir que a requisição HTTP seja feita apenas uma vez.

tap(courses => console.log(courses)):
O operador tap() é usado para observar os valores emitidos pelo Observable sem afetar o fluxo de dados. Neste caso, estamos usando o tap() para 
imprimir a lista de cursos no console.

Portanto, quando você chama o método list(), ele faz uma requisição HTTP GET para o endpoint especificado em this.API, obtém a lista de cursos, 
imprime-a no console e retorna um Observable com a lista de cursos. A utilização de first() garante que a requisição seja feita somente uma vez, 
e tap() é usado para observar os valores emitidos sem alterar o fluxo de dados.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

No Angular, a diretiva *ngFor é frequentemente usada para iterar sobre uma lista de itens e renderizar o conteúdo correspondente no template. No 
entanto, quando você está trabalhando com Observables, como os retornados por requisições HTTP, você pode usar a diretiva *ngFor juntamente com 
a palavra-chave async para simplificar o processo de renderização de dados assíncronos no template.

A palavra-chave async permite que o Angular gerencie automaticamente a assinatura do Observable e atualize o template sempre que novos valores 
forem emitidos. Isso torna o código mais limpo e evita que você precise manipular manualmente a assinatura e desinscrição do Observable.

É importante mencionar que, ao usar async, o Angular também cuida automaticamente do ciclo de vida do Observable, desinscrevendo-o quando o 
componente for destruído. Isso ajuda a evitar possíveis vazamentos de memória.

Em resumo, a diretiva async é uma ferramenta poderosa e conveniente no Angular para lidar com dados assíncronos e simplificar a renderização de 
listas de itens em templates. Ela facilita a exibição de dados de Observables no template de forma reativa e responsiva.

Vale ressaltar que o async pode ser usado em outras diretivas também, como por exemplo, *ngIf.

--------- // ----------

courses$: Este é o nome da variável. O caractere $ é frequentemente usado como uma convenção para indicar que a variável é um Observable.

--------- // ----------

Esse script usa a diretiva estrutural *ngIf juntamente com a diretiva async para renderizar condicionalmente um conteúdo no template com base no 
valor emitido por um Observable. Além disso, ele utiliza a diretiva as para criar um alias para o valor emitido pelo Observable.

Vamos analisar o script em detalhes:

 <div *ngIf="courses$ | async as courses; else loading">

Explicação passo a passo:

1. `*ngIf="courses$ | async as courses; else loading"`:
   - `*ngIf` é uma diretiva estrutural que permite renderizar ou não o conteúdo com base em uma expressão condicional.
   - `courses$` é um Observable que emite uma lista de cursos.
   - `async` é usado para assinar o Observable e atualizar o template sempre que o valor é emitido.
   - `as courses` cria um alias chamado `courses` para o valor emitido pelo Observable.
   - `else loading` é usado para especificar o template alternativo (com o alias `loading`) a ser renderizado quando o valor do Observable ainda 
      não foi emitido.

2. `<div *ngIf="courses$ | async as courses; else loading">`:
   - Se o Observable `courses$` já emitiu um valor, o conteúdo dentro deste elemento `<div>` será renderizado. Isso inclui um loop `*ngFor` para 
     iterar sobre os cursos e renderizá-los em uma lista.

3. `<ng-template #loading>`:
   - Este é o template alternativo (definido com a diretiva `else`) a ser exibido quando o valor do Observable ainda não foi emitido.
   - Ele contém a mensagem "Carregando..." para indicar ao usuário que os dados estão sendo buscados.

   <ng-template #loading>
    <mat-spinner></mat-spinner>
   </ng-template>

Em resumo, esse script permite renderizar uma lista de cursos se o Observable `courses$` já emitiu um valor. Caso contrário, ele exibe a mensagem 
"Carregando..." enquanto aguarda o valor ser emitido. Isso cria uma experiência de usuário mais amigável ao carregar dados assíncronos.

--------- // ----------

Criar um module shared - comando: ng g m shared
Criar um componente shared - comando: ng g c shared/components/error-dialog

Vamos criar o module e o component para tratar os erros que possam vir a ocorrer e que serão mostrados para o usuário.
Como vamos trabalhar com o Dialog, vamos importar 'MatDialogModule' no nosso modulo app-material.module.ts e no nosso shared.module.ts 
vamos importar o AppMaterialModule.  

API - site: https://material.angular.io/components/dialog/api
import do Dialog na Angular Material: import {MatDialogModule} from '@angular/material/dialog'; 

-------------------------------------------------------------------- // -----------------------------------------------------------------------

API - site: https://material.angular.io/components/icon/api
API reference for Angular Material icon: import {MatIconModule} from '@angular/material/icon';

Biblioteca de icons do Material Angular:
https://fonts.google.com/icons?hl=pt-br

--------- // ----------

Vamos criar uma funcionalidade onde dependendo da categoria vai criar um icone diferente, para fazer isso vamos utilizar uma classe no Angular
que se chama pipe, essa classe transforma valores, ou seja, dado um valor, vai existir uma lógica e retorna esse valor transformado.

No Angular, os pipes são recursos poderosos para transformar e formatar dados de maneira flexível e reutilizável diretamente nos templates. Eles 
são usados para realizar transformações visuais em valores exibidos ao usuário, sem modificar os valores originais nos componentes.

Aqui estão os principais pontos sobre as classes de pipes no Angular:

1. **Transformação de Dados:** Os pipes permitem que você transforme, formate e manipule dados antes de serem exibidos nos templates. Isso é 
útil para exibir datas em formatos diferentes, formatar números, ordenar listas e muito mais.

2. **Sintaxe:** Os pipes são usados dentro das expressões interpoladas ({{ }}) nos templates. A sintaxe básica é `{{ valor | pipe }}`, onde 
`valor` é o dado a ser transformado e `pipe` é o nome do pipe a ser aplicado.

3. **Encadeamento:** Você pode encadear vários pipes para realizar transformações consecutivas em um dado. Por exemplo, 
`{{ data | date | uppercase }}` primeiro formata a data e depois converte o texto resultante para maiúsculas.

4. **Parâmetros:** Alguns pipes podem aceitar parâmetros adicionais para personalizar a transformação. Por exemplo, o pipe `date` aceita um 
formato de data específico como parâmetro.

5. **Criar Pipes Personalizados:** Além dos pipes embutidos fornecidos pelo Angular (como `date`, `uppercase`, `currency`, etc.), você pode criar 
seus próprios pipes personalizados. Isso é útil quando você precisa realizar transformações específicas ao seu aplicativo.

Os pipes são uma maneira poderosa de melhorar a apresentação dos dados em seus templates, tornando-os mais legíveis e compreensíveis para os 
usuários. Eles também ajudam a manter a lógica de transformação separada da lógica de negócios nos componentes, seguindo os princípios de uma 
arquitetura limpa e modular.

Gerando um modulo com nome pipe no modulo compartilhado para q outros módulos possam usá-lo. Por padrão o nosso pipe category só estará visível
apenas para o módulo shared.
comando: ng g pipe shared/pipes/category

Depois de criado o pipe vamos importar o 'CategoryPipe' no exports para q possa ser compartilhado para o módulo 
shared.module.ts.

--------- // ----------
O PipeTransform 

A interface `PipeTransform` é um componente fundamental no Angular relacionado ao uso de pipes. Ela define um contrato que os pipes devem seguir 
para realizar transformações de dados em templates.

Aqui estão os principais pontos sobre a interface `PipeTransform`:

1. **Definição do Contrato:** A interface `PipeTransform` é usada para definir o contrato que um pipe deve seguir. Isso significa que um pipe 
que implementa a interface `PipeTransform` deve fornecer uma implementação para o método `transform()`.

2. **Método `transform()`:** O método `transform()` é o ponto central do pipe. Ele recebe pelo menos um argumento (o valor a ser transformado) 
e, opcionalmente, pode receber mais argumentos (parâmetros) dependendo das necessidades do pipe.

3. **Retorno:** O método `transform()` deve retornar o valor transformado. Isso pode ser qualquer tipo de dado que seja apropriado para a 
transformação pretendida.

4. **Uso em Pipes Personalizados:** Ao criar um pipe personalizado, você deve implementar a interface `PipeTransform` e, em seguida, implementar 
o método `transform()` de acordo com a lógica de transformação desejada.

Quando você usa o pipe no template, o Angular invocará automaticamente o método `transform()` do pipe, passando os argumentos apropriados.

A interface `PipeTransform` é um dos principais conceitos que permite a criação de pipes personalizados no Angular, tornando possível a 
transformação flexível e reutilizável de dados nos templates.

----------------------------------------------------------------------- // -----------------------------------------------------------------------

IMPORTANTE!!!!!!!!!

Para resolver o problema do cors vamos criar um proxy no Angular, o objetivo é fazer com que esse proxy funcione como se estivesse fazendo uma 
chamada para o mesmo domínio, não importado que o dominio do back-end (API Spring) e do meu front-end (Angular) sejam diferentes, ou seja, o uso 
do proxy vai fazer com que tenha uma chamada do meu back-end para o meu front-end e vice-versa. Então, vamos criar um arquivo 'proxy.conf.js' na
raiz do projeto.
Também vamos adicionar o package.json vamos fazer a seguinte modificação na propriedade start: 
"start": "ng serve --proxy-config proxy.conf.js"
Essa modificação tem como objetivo que quando o ng serve for gerada vai ser utilizado o proxy. Portanto, sempre que for usar o ng serve, agora teremos 
que utilizar o comando 'npm run start' para que possamos sempre utilizar esse proxy.

Vale ressaltar como estamos utilizando um proxy para resolver os  problemas que viriam com o cors o servidor agora irá ser executado com o 
comando: npm run start (na parte do Angular).

---------- // ----------
Vamos utilizar 'fasterXML' que possui uma biblioteca 'jackson' para fazer o parciamento entre os parâmetros do objeto Curso para Json e vice-versa. Vale ressaltar que a propriedade id
definida no front-end (Angular) está definida da seguinte maneira: _id. Já na nossa API Spring Boot a propriedade está definida como 'id'. Logo, 
repare que as propriedades estão nomeadas de forma diferente, e para resolver isso utilizaremos como foi dito a biblioteca 'jackson'. Essa 
anotação é o @JsonProperty, ela fornecida pela biblioteca Jackson, que é amplamente utilizada para trabalhar com JSON em aplicações Java. Essa 
anotação permite personalizar o mapeamento entre nomes de propriedades de uma classe Java e nomes de campos correspondentes em JSON.

No caso:
 @JsonProperty("_id")
 private String id;

Neste exemplo, a propriedade id na classe Person é mapeada para a chave _id no JSON. Isso significa que, ao serializar um objeto Person em JSON, 
a chave _id será usada no JSON resultante. Da mesma forma, ao desserializar JSON para um objeto Person, o Jackson procurará a chave _id no JSON 
e mapeará seu valor para a propriedade id na classe Java.
A anotação @JsonProperty é especialmente útil quando você precisa trabalhar com APIs RESTful ou outras fontes de dados JSON que usam nomes de 
chaves diferentes daqueles usados em suas classes de modelo Java. Ela ajuda a manter um mapeamento preciso e permite que você tenha um controle
mais granular sobre a serialização e desserialização de dados JSON.

Quando você serializa um objeto Java para JSON ou desserializa JSON para um objeto Java usando o Jackson, os nomes das propriedades na classe Java nem sempre precisam ser idênticos aos nomes das chaves nos objetos JSON. A anotação @JsonProperty permite especificar explicitamente o nome da chave JSON correspondente a uma propriedade específica na classe Java.

E vamos  utilizar a anotação '@ResponseBody é uma anotação fornecida pelo Spring Framework em aplicações Spring MVC que indica que o valor 
retornado por um método de controlador deve ser serializado e incluído diretamente na resposta HTTP como corpo (body) da resposta. Ela é usada 
para indicar que um método de controlador deve retornar o corpo da resposta em vez de redirecionar para uma visualização (view).
Quando você adiciona a anotação @ResponseBody a um método de controlador, o Spring MVC assume que o valor retornado deve ser convertido em um 
formato apropriado, como JSON, XML ou outros, dependendo da configuração da aplicação e do cabeçalho Accept da solicitação HTTP.

A anotação @ResponseBody é frequentemente usada em conjunto com a anotação @RestController, que combina a funcionalidade de @Controller e 
@ResponseBody, permitindo que você crie facilmente APIs RESTful em sua aplicação Spring.

----------------------------------------------------------------------- // -----------------------------------------------------------------------

Vale destacar que vamos utilizar o <mat-header-cell> para customizar a criação das ações dos botões de cadastrar curso, é importante também dizer 
que junto com o <mat-header-cell> utiliza o <mat-cell> que seria o corpo. Logo, é preciso usar ambos, caso contrário, dará erro.

Essa tag e mais a diretiva <mat-cell *matCellDef="let course"> tem a função de que para cada registro de curso que vier na minha coleção será 
feito alguma coisa. Ou seja, é uma diretiva estrutural do Angular Material usada para definir o conteúdo que será renderizado na célula. O trecho 
let course cria uma variável course que contém os dados da linha atual da tabela.

Lembrando que esse script faz parte do Angular Material e está relacionado ao uso de tabelas (mat-table) para exibir dados tabulares em um 
formato de tabela. Mais especificamente, ele está relacionado ao conteúdo de uma célula (cell) dentro de uma linha (row) da tabela.

---------- // ----------
Vamos criar um componente para o formulário, pois utilizaremos para o roteamento.

Comando: ng g c courses/course-form

---------- // ----------

Método da ação do botão add o curso:

```
onAdd() {
  this.router.navigate(["new"], { relativeTo: this.route });
}
```

O script está relacionado à navegação em um aplicativo Angular. Ele é usado para redirecionar o usuário para uma nova rota, quando um evento 
específico, como um clique em um botão, ocorre.

Aqui está a explicação detalhada:

- `onAdd()`: Isso é um método chamado `onAdd()`, geralmente associado a um evento, como o clique em um botão. Quando esse evento ocorre, o método 
  é executado.

- `this.router.navigate(["new"], { relativeTo: this.route })`:
  - `this.router.navigate(...)`: Isso é usado para navegar para uma nova rota.

  - `["new"]`: Isso é um array que especifica a nova rota para a qual você deseja navegar. Nesse caso, a rota é definida como "new". Isso pode 
     ser ajustado de acordo com as rotas definidas em seu aplicativo.

  - `{ relativeTo: this.route }`: Isso é uma opção que especifica que a navegação é relativa à rota atual. Isso é útil quando você está usando 
     roteamento aninhado (nested routing) e deseja navegar com base na rota atual.

Em um cenário de roteamento aninhado, isso significa que o componente atual possui rotas aninhadas dentro dele. O método `onAdd()` é usado para 
navegar para uma nova rota chamada "new" em relação à rota atual. Isso pode ser usado, por exemplo, para abrir um formulário de criação de um 
novo item.

Em resumo, o script `onAdd()` é usado para navegar para uma nova rota em relação à rota atual, com base em um evento, como o clique em um botão. 


Certamente! A classe `ReactiveFormsModule` é parte do módulo `@angular/forms` do Angular e é usada para habilitar e simplificar o gerenciamento de formulários reativos em seu aplicativo. Formulários reativos são uma abordagem poderosa para lidar com a entrada do usuário e a validação de dados em aplicativos Angular.

Aqui estão os principais pontos sobre a classe `ReactiveFormsModule`:

1. **Formulários Reativos:** Formulários reativos são uma alternativa à abordagem de formulários template-driven no Angular. Eles permitem que você construa formulários dinâmicos e complexos usando código TypeScript para controlar o comportamento dos formulários e a validação dos dados.

2. **Facilita a Manipulação:** O `ReactiveFormsModule` fornece classes e métodos para criar, controlar e validar campos de formulário de maneira programática. Isso é particularmente útil ao criar formulários mais complexos que requerem validações personalizadas, lógica de exibição condicional e manipulação avançada de dados.

3. **FormGroup e FormControl:** A classe `FormGroup` é usada para criar grupos de campos relacionados, enquanto a classe `FormControl` é usada para criar campos individuais dentro de um grupo. Os `FormGroup` e `FormControl` permitem que você defina validações, valores iniciais e outras configurações.

4. **Validação:** Com o `ReactiveFormsModule`, você pode definir validações de maneira declarativa e programática. Isso inclui validações pré-construídas, como `required` e `minLength`, além de validações personalizadas que você pode definir.

5. **Dinamismo:** Como os formulários reativos são construídos programaticamente usando TypeScript, você pode facilmente adicionar ou remover campos dinamicamente, reagir a eventos e alterações de estado e controlar o fluxo de dados de maneira mais precisa.

6. **Tratamento de Erros:** Os formulários reativos fornecem maneiras eficazes de tratar erros e exibir mensagens de validação aos usuários. Você pode acessar os estados de validação dos campos e grupos para exibir feedback apropriado.

Para usar o `ReactiveFormsModule`, você deve importá-lo no módulo onde você deseja usar formulários reativos. Geralmente, você importa o módulo `ReactiveFormsModule` de `@angular/forms`:

```typescript
import { ReactiveFormsModule } from '@angular/forms';

@NgModule({
  imports: [
    // ...
    ReactiveFormsModule
  ],
  // ...
})
export class YourModule { }
```
----------------------------------------------------------------------- // -----------------------------------------------------------------------

A classe ReactiveFormsModule é parte do módulo @angular/forms do Angular e é usada para habilitar e simplificar o gerenciamento de formulários 
reativos em seu aplicativo. Formulários reativos são uma abordagem poderosa para lidar com a entrada do usuário e a validação de dados em 
aplicativos Angular.

Aqui estão os principais pontos sobre a classe `ReactiveFormsModule`:

1. **Formulários Reativos:** Formulários reativos são uma alternativa à abordagem de formulários template-driven no Angular. Eles permitem que 
   você construa formulários dinâmicos e complexos usando código TypeScript para controlar o comportamento dos formulários e a validação dos 
   dados.

2. **Facilita a Manipulação:** O `ReactiveFormsModule` fornece classes e métodos para criar, controlar e validar campos de formulário de maneira 
   programática. Isso é particularmente útil ao criar formulários mais complexos que requerem validações personalizadas, lógica de exibição 
   condicional e manipulação avançada de dados.

3. **FormGroup e FormControl:** A classe `FormGroup` é usada para criar grupos de campos relacionados, enquanto a classe `FormControl` é usada 
   para criar campos individuais dentro de um grupo. Os `FormGroup` e `FormControl` permitem que você defina validações, valores iniciais e 
   outras configurações.

4. **Validação:** Com o `ReactiveFormsModule`, você pode definir validações de maneira declarativa e programática. Isso inclui validações 
   pré-construídas, como `required` e `minLength`, além de validações personalizadas que você pode definir.

5. **Dinamismo:** Como os formulários reativos são construídos programaticamente usando TypeScript, você pode facilmente adicionar ou remover 
   campos dinamicamente, reagir a eventos e alterações de estado e controlar o fluxo de dados de maneira mais precisa.

6. **Tratamento de Erros:** Os formulários reativos fornecem maneiras eficazes de tratar erros e exibir mensagens de validação aos usuários. Você 
   pode acessar os estados de validação dos campos e grupos para exibir feedback apropriado.

Em resumo, o `ReactiveFormsModule` é uma parte essencial da abordagem de formulários reativos no Angular. Ele fornece ferramentas poderosas 
para criar, gerenciar e validar formulários dinâmicos de maneira programática, permitindo uma maior flexibilidade e controle em comparação com 
formulários template-driven.

---------- // ----------
No courses-form.component.ts:

A classe `FormBuilder` é uma parte importante do Angular e faz parte do módulo `@angular/forms`. Ela fornece um serviço que simplifica a criação 
e gerenciamento de instâncias `FormGroup` e `FormControl` em formulários reativos.

Aqui estão os principais pontos sobre a classe `FormBuilder`:

1. **Simplifica a Criação de Formulários:** A principal função do `FormBuilder` é simplificar a criação de formulários reativos. Em vez de criar 
    manualmente instâncias de `FormGroup` e `FormControl`, você pode usar os métodos do `FormBuilder` para criar essas instâncias de forma mais ]
    concisa.

2. **Métodos do FormBuilder:** O `FormBuilder` fornece uma série de métodos para criar instâncias de `FormGroup` e `FormControl` com configurações 
   específicas. Esses métodos incluem `group()`, `control()`, `array()`, entre outros.

3. **Configurações Simplificadas:** Os métodos do `FormBuilder` permitem definir configurações, como valores iniciais, validadores e outros 
   parâmetros, de maneira mais legível e concisa.

4. **Exemplo de Uso:** Aqui está um exemplo simples de como o `FormBuilder` pode ser usado para criar um `FormGroup` com campos `FormControl`:

O `FormBuilder` é injetado no construtor do componente. Em seguida, usamos o método `group()` para criar um `FormGroup`. Cada campo é definido 
usando o método `control()`, que aceita um valor inicial e uma série de validadores.

Ao usar o `FormBuilder`, você pode definir rapidamente as estruturas de seus formulários reativos, melhorando a legibilidade do código e 
tornando-o mais fácil de manter.

Em resumo, o `FormBuilder` é um serviço no Angular que simplifica a criação e configuração de instâncias de `FormGroup` e `FormControl` em 
formulários reativos. Ele é uma ferramenta útil para tornar a criação de formulários mais eficiente e legível.

```
form:FormGroup;

  constructor(private formBuilder:FormBuilder) { 
    this.form = this.formBuilder.group({
      name:[null],
      category:[null]
    });
  }
```
O objetivo é criar um formulário que tenha dois campos: "name" e "category".

Aqui está a explicação passo a passo:

form: FormGroup;: Declara uma propriedade chamada form que é do tipo FormGroup. Esta propriedade será usada para 
      representar o formulário reativo.

constructor(private formBuilder: FormBuilder) { ... }: O construtor da classe. Ele é usado para inicializar a classe e 
pode receber parâmetros. Neste caso, o construtor recebe uma instância do serviço FormBuilder através da injeção de 
dependência.

this.form = this.formBuilder.group({ ... });: Aqui, estamos usando o serviço FormBuilder para criar um FormGroup. O 
método group() é usado para criar um grupo de campos relacionados no formulário.

name: [null],: Isso define um campo chamado "name" no formulário com um valor inicial de null.

category: [null]: Isso define um campo chamado "category" no formulário com um valor inicial de null.

No geral, esse script cria um formulário reativo com dois campos: "name" e "category". Os valores iniciais dos campos 
são definidos como null. Isso é apenas um exemplo básico, mas você pode adicionar validadores, valores iniciais e outras 
configurações mais avançadas aos campos do formulário conforme necessário.

---------- // ----------
Vamos agora criar o formulário de cadastro do curso, para isso vamos utilizar o anglar material e o 'form field', portanto, vamos importar a API
e adicionar no 'app-material.module.ts'.

Link: https://material.angular.io/components/form-field/api
API reference for Angular Material form-field
import {MatFormFieldModule} from '@angular/material/form-field';

Também vamos importar o MatInputModule - import: 
import { MatInputModule } from '@angular/material/input'; 

E também vamos utilizar o Card para agrupar os campos (inputs).

Lembrando que o nosso courses-module.ts já está  exportando (exports) o sharedModule que também tem o app-material.module.ts (AppMaterialModule), 
logo não precisamos ficar importando as API do angular material no courses-module.ts

Construindo o formulário - bom saber: 
 -> É importante ressaltar que precisamos linkar a tag <form> do course-form.component.html com a variavel 'form' do course-form.component.ts. E vamos
    fazer isso através da diretiva formGroup, exemplificando: <form [formGroup]="form"> ...

 -> Próximo passo é associar o campo de input com a variável 'name' e 'category'. E para fazer isso utilizaremos o 'formControlName', 
 exemplificando: <input matInput placeholder="Nome" formControlName="name">